outlets = 1;var vdim = [640,480];var framearray = new Array();var videoplane = new JitterObject ("jit.gl.videoplane", "out.1");videoplane.texturename = "/cam.1";videoplane.transform_reset = 1 ; videoplane.automatic = 0;var outslab = new JitterObject("jit.gl.slab","out.1");outslab.inputs = 2;outslab.colormode = "argb";outslab.blend_enable = 1;outslab.file = "co.normal.jxs";outslab.param("amount",0.);var outframeA = 0;var outframeB = 0;var tweenfade = 0.;var recmode = 0;var rechead = 0;var modname = "/buf.0"var playmode = 0;var playhead = 0;var delayframes = 0.;var framecount = 60;var vcount = 0;initialmaxframes(framecount);function set_mod_name(mod_name){	modname = mod_name;}function jit_gl_texture(in_tex){//    post ("receive texture "+in_tex+"\n");        if (recmode==1) {        storeframe();    }	if (playmode==1){        playframes();    } 	else {        outlet(0,"bang");            }}//MSG IN - store and/or retrive frames. also the clock!function record(){    recmode = 1;}//MSG IN - recmode onfunction stop_record (){    recmode = 0;}//MSG IN - recmode offfunction reset_record (){    rechead = 0;}//MSG IN - reset record headfunction storeframe(in_name){//	post("store texture "+in_name + "\n");	videoplane.capture = framearray[rechead].name ; 	rechead++;	if (rechead >= framecount) {		reset_record();	}}//store frame and advance recheadfunction play(newspeed){    playmode = 1;}//MSG IN - turn playmode on and optionally set playspeedfunction stop_play (){    playmode = 0;}//MSG IN - playmode offfunction playframes(){//	post ("print texture ");        playhead = ((rechead - (delayframes+1.5)) + (3*framecount)) % framecount;//	post ("pour frame "+playhead+"\n");	    tweenfade = 0.5-(playhead - Math.round(playhead));            outframeA = (Math.round(playhead))%framecount -1.;    outframeB = (outframeA + 1.0)%framecount;    outslab.param("amount",tweenfade);    outslab.sendinput(framearray[outframeA], 0);    outslab.sendinput(framearray[outframeB], 1);    outslab.draw();    //    post("texture "+framearray[outframeA].name+" done -> out\n");//    outlet(0,"jit_gl_texture", outslab.out_name);               outlet(0,"jit_gl_texture", framearray[outframeA].name);           //    advance_playhead();}//MSG OUT - send out frame and advance playheadfunction delay (del_time){    delayframes = del_time;}//MSG IN - set number of frames to delayfunction dim(width,height){/*    vdim[0] = width;    vdim[1] = height;    for (i=0;i<vcount;i++) {        framearray[i].dim = vdim;    }*/}//MSG IN - set width and heigh of all jit.matrix objectsfunction freeoldbuffer(){    vcount = framecount;    for (var i=0;i<vcount;i++) {        framearray[i].unbind();        framearray[i].freepeer();    }}//dispose of old bufferfunction maxframes(c){//	post ("rebuild array\n");    freeoldbuffer();    if (c<1)        c = 1;    vcount = c;    for (var i=0;i<vcount;i++) {    	texname = ""+modname+"/tex."+ i;	framearray[i] = new JitterObject("jit.gl.texture", "out.1");	framearray[i].name = texname;    }    framecount = c;    in_point = 0;    out_point = framecount;}    //reallocate buffer to new sizefunction initialmaxframes(c){	post ("first build array\n");    if (c<1)        c = 1;    vcount = c;    for (var i=0;i<vcount;i++) {    	texname = ""+modname+"/tex"+ i;	framearray[i] = new JitterObject("jit.gl.texture", "out.1");	framearray[i].name = texname;    }    framecount = c;    in_point = 0;    out_point = framecount;}    //initial buffer allocation